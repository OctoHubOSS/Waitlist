generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// NextAuth required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Core models
model User {
  id                 String              @id @default(cuid())
  name               String?
  email              String              @unique
  emailVerified      DateTime?
  image              String?
  password           String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  accounts           Account[]
  sessions           Session[]
  waitlistSubscriber WaitlistSubscriber?
  featureRequests    FeatureRequest[]
  comments           Comment[]
  reactions          Reaction[]
  notifications      Notification[]
  responses          Response[]
  auditLogs          AuditLog[] // Records of user activity
}

model WaitlistSubscriber {
  id            String         @id @default(cuid())
  email         String         @unique
  name          String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  status        WaitlistStatus @default(PENDING)
  source        String?        @db.Text
  metadata      Json?
  referralCode  String?        @unique
  referredBy    String?
  referralCount Int            @default(0)
  position      Int?
  priority      Int            @default(0)
  inviteSent    Boolean        @default(false)
  inviteSentAt  DateTime?
  user          User?          @relation(fields: [userId], references: [id])
  userId        String?        @unique
  notifications Notification[]
  responses     Response[]
  auditLogs     AuditLog[]

  @@index([email, status])
  @@index([createdAt])
  @@index([referralCode])
}

enum WaitlistStatus {
  PENDING
  SUBSCRIBED
  UNSUBSCRIBED
  BOUNCED
}

model FeatureRequest {
  id          String        @id @default(cuid())
  title       String
  description String        @db.Text
  status      RequestStatus @default(OPEN)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  author      User          @relation(fields: [authorId], references: [id])
  authorId    String
  comments    Comment[]
  reactions   Reaction[]
  auditLogs   AuditLog[]

  @@index([status])
  @@index([createdAt])
}

enum RequestStatus {
  OPEN
  UNDER_REVIEW
  PLANNED
  IN_PROGRESS
  COMPLETED
  DECLINED
}

model Comment {
  id               String         @id @default(cuid())
  content          String         @db.Text
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  author           User           @relation(fields: [authorId], references: [id])
  authorId         String
  featureRequest   FeatureRequest @relation(fields: [featureRequestId], references: [id], onDelete: Cascade)
  featureRequestId String
  reactions        Reaction[]
  auditLogs        AuditLog[]

  @@index([featureRequestId])
  @@index([authorId])
}

model Reaction {
  id               String          @id @default(cuid())
  type             ReactionType
  createdAt        DateTime        @default(now())
  user             User            @relation(fields: [userId], references: [id])
  userId           String
  featureRequest   FeatureRequest? @relation(fields: [featureRequestId], references: [id], onDelete: Cascade)
  featureRequestId String?
  comment          Comment?        @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId        String?
  auditLogs        AuditLog[]

  @@unique([userId, featureRequestId, type])
  @@unique([userId, commentId, type])
  @@index([featureRequestId, type])
  @@index([commentId, type])
}

enum ReactionType {
  LIKE
  DISLIKE
}

// Survey system models
model Survey {
  id          String     @id @default(cuid())
  title       String
  description String?    @db.Text
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  isActive    Boolean    @default(true)
  questions   Question[]
  responses   Response[]
  auditLogs   AuditLog[]
}

model Question {
  id         String       @id @default(cuid())
  text       String       @db.Text
  type       QuestionType
  options    Json? // For multiple choice questions
  isRequired Boolean      @default(false)
  order      Int
  survey     Survey       @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  surveyId   String
  answers    Answer[]

  @@index([surveyId])
}

enum QuestionType {
  TEXT
  MULTIPLE_CHOICE
  CHECKBOX
  RATING
}

model Response {
  id           String              @id @default(cuid())
  createdAt    DateTime            @default(now())
  survey       Survey              @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  surveyId     String
  user         User?               @relation(fields: [userId], references: [id])
  userId       String?
  subscriber   WaitlistSubscriber? @relation(fields: [subscriberId], references: [id])
  subscriberId String?
  answers      Answer[]
  auditLogs    AuditLog[]

  @@index([surveyId])
  @@index([userId])
  @@index([subscriberId])
}

model Answer {
  id         String   @id @default(cuid())
  value      String   @db.Text
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId String
  response   Response @relation(fields: [responseId], references: [id], onDelete: Cascade)
  responseId String

  @@index([responseId])
  @@index([questionId])
}

// Notification system
model Notification {
  id           String              @id @default(cuid())
  type         NotificationType
  title        String
  content      String              @db.Text
  isRead       Boolean             @default(false)
  createdAt    DateTime            @default(now())
  user         User?               @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String?
  subscriber   WaitlistSubscriber? @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
  subscriberId String?
  auditLogs    AuditLog[]

  @@index([userId, isRead])
  @@index([subscriberId, isRead])
}

enum NotificationType {
  WAITLIST_UPDATE
  POSITION_CHANGE
  FEATURE_UPDATE
  COMMENT_REPLY
  REACTION
  INVITE
  SURVEY
}

// Product roadmap milestones
model Milestone {
  id          String     @id @default(cuid())
  title       String
  description String     @db.Text
  targetDate  DateTime?
  completedAt DateTime?
  progress    Int        @default(0)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  isPublic    Boolean    @default(true)
  auditLogs   AuditLog[]
}

// Comprehensive Audit Log system
model AuditLog {
  id         String         @id @default(cuid())
  timestamp  DateTime       @default(now())
  action     AuditLogAction
  entityType String // The type of entity being acted upon
  entityId   String // ID of the entity being acted upon
  oldData    Json? // Previous state (if applicable)
  newData    Json? // New state (if applicable)
  ipAddress  String?
  userAgent  String?        @db.Text

  // Optional relations to specific entities
  user             User?               @relation(fields: [userId], references: [id])
  userId           String?
  subscriber       WaitlistSubscriber? @relation(fields: [subscriberId], references: [id])
  subscriberId     String?
  featureRequest   FeatureRequest?     @relation(fields: [featureRequestId], references: [id])
  featureRequestId String?
  comment          Comment?            @relation(fields: [commentId], references: [id])
  commentId        String?
  reaction         Reaction?           @relation(fields: [reactionId], references: [id])
  reactionId       String?
  notification     Notification?       @relation(fields: [notificationId], references: [id])
  notificationId   String?
  survey           Survey?             @relation(fields: [surveyId], references: [id])
  surveyId         String?
  response         Response?           @relation(fields: [responseId], references: [id])
  responseId       String?
  milestone        Milestone?          @relation(fields: [milestoneId], references: [id])
  milestoneId      String?

  metadata Json? // Additional contextual information

  @@index([timestamp])
  @@index([action])
  @@index([entityType, entityId])
  @@index([userId])
  @@index([subscriberId])
}

enum AuditLogAction {
  ACCOUNT_CREATED
  ACCOUNT_UPDATED
  ACCOUNT_DELETED
  LOGIN_SUCCESS
  LOGIN_FAILED
  LOGOUT
  PASSWORD_RESET_REQUESTED
  PASSWORD_CHANGED
  EMAIL_CHANGED
  WAITLIST_JOINED
  WAITLIST_STATUS_CHANGED
  FEATURE_REQUESTED
  FEATURE_UPDATED
  FEATURE_STATUS_CHANGED
  COMMENT_ADDED
  COMMENT_UPDATED
  COMMENT_DELETED
  REACTION_ADDED
  REACTION_REMOVED
  SURVEY_SUBMITTED
  NOTIFICATION_SENT
  NOTIFICATION_READ
  INVITE_SENT
  REFERRAL_USED
  MILESTONE_CREATED
  MILESTONE_UPDATED
  ADMIN_ACTION
}
